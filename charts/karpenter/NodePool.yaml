apiVersion: karpenter.sh/v1
kind: NodePool
metadata:
  name: default
spec:
  # 1. The Link
  # This connects this logic to the Hardware Config (EC2NodeClass) above.
  template:
    spec:
      nodeClassRef:
        group: karpenter.k8s.aws
        kind: EC2NodeClass
        name: default

      # 2. Requirements (The Constraints)
      # This acts like a filter on the EC2 inventory.
      requirements:
        # A. Architecture: Only Intel/AMD 64-bit
        - key: kubernetes.io/arch
          operator: In
          values: ["amd64"]
        
        # B. Capacity: Prefer Spot, but allow On-Demand if Spot is unavailable
        - key: karpenter.sh/capacity-type
          operator: In
          values: ["spot", "on-demand"]

        # C. The "Allowed List" (Your Safety Net)
        # ONLY list the instances you are willing to spend credits on.
        - key: node.kubernetes.io/instance-type 
          operator: In
          values: 
            - "t3.small"       # Cheap, good for system pods
            - "c7i-flex.large" # Compute optimized 
            - "m7i-flex.large" # Memory optimized 

  # 3. Global Limits (The Budget)
  # If the total cluster usage hits this, Karpenter STOPS creating nodes.
  limits:
    cpu: 10
    memory: 40Gi

  # 4. Disruption (The Cleaner)
  # How aggressively should Karpenter delete nodes to save money?
  disruption:
    # "WhenUnderutilized": If a node is empty or can be packed better, delete it.
    # "WhenEmpty": Only delete if completely empty.
    consolidationPolicy: WhenUnderutilized
    
    # How long to wait after a node becomes efficient/empty before killing it?
    consolidateAfter: 30s
    
    # Hard Time Limit: Kill this node after 7 days no matter what (good for security patching)
    expireAfter: 168h