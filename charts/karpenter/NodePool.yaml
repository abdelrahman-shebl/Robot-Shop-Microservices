apiVersion: karpenter.sh/v1
kind: NodePool
metadata:
  name: default
spec:
  # 1. The Link
  # This connects this logic to the Hardware Config (EC2NodeClass) above.
  template:
    spec:
      nodeClassRef:
        group: karpenter.k8s.aws
        kind: EC2NodeClass
        name: default

      # 2. Requirements (The Constraints)
      # This acts like a filter on the EC2 inventory.
      requirements:
        # A. Architecture: Only Intel/AMD 64-bit
        - key: kubernetes.io/arch
          operator: In
          values: ["amd64"]
        
        # B. Capacity: Prefer Spot, but allow On-Demand if Spot is unavailable
        - key: karpenter.sh/capacity-type
          operator: In
          values: ["spot", "on-demand"]

        # C. Instance Families: Only use Compute (c) or Memory (m) optimized
        - key: karpenter.k8s.aws/instance-category
          operator: In
          values: ["c", "m"]

        # D. Generation: Don't use old hardware (like c3, c4). Use gen 5 or newer.
        - key: karpenter.k8s.aws/instance-generation
          operator: Gt
          values: ["4"]

  # 3. Global Limits (The Budget)
  # If the total cluster usage hits this, Karpenter STOPS creating nodes.
  limits:
    cpu: 1000
    memory: 1000Gi

  # 4. Disruption (The Cleaner)
  # How aggressively should Karpenter delete nodes to save money?
  disruption:
    # "WhenUnderutilized": If a node is empty or can be packed better, delete it.
    # "WhenEmpty": Only delete if completely empty.
    consolidationPolicy: WhenUnderutilized
    
    # How long to wait after a node becomes efficient/empty before killing it?
    consolidateAfter: 30s
    
    # Hard Time Limit: Kill this node after 7 days no matter what (good for security patching)
    expireAfter: 168h